<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>channel - CC-Table： 专注协同计算技术研发</title>
    <link>https://taodanfang.github.io/categories/channel/</link>
    <description>Recent content in channel on CC-Table： 专注协同计算技术研发</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 28 Nov 2021 00:50:41 +0800</lastBuildDate>
    
        <atom:link href="https://taodanfang.github.io/categories/channel/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Golang 并发开发实践（6）- 微服务与Context</title>
      <link>https://taodanfang.github.io/posts/golang-channel-study-6-1/</link>
      <pubDate>Sun, 28 Nov 2021 00:50:41 +0800</pubDate>
      
      <guid>https://taodanfang.github.io/posts/golang-channel-study-6-1/</guid>
      <description>&lt;p&gt;A Context carries a deadline, a cancelation signal, and other values across API boundaries. 一个上下文携带着一个到期时间，一个取消信号以及其它的值跨越 API 的界线。&lt;/p&gt;
&lt;p&gt;Google 在内部要求 Go 开发者必须将 Context 作为 API 的第一个参数，无论是提供给别人还是自己调用。&lt;/p&gt;</description>
    </item><item>
      <title>Golang 并发开发实践（5）- Channel 原理与模式</title>
      <link>https://taodanfang.github.io/posts/golang-channel-study-5-1/</link>
      <pubDate>Sat, 27 Nov 2021 00:08:16 +0800</pubDate>
      
      <guid>https://taodanfang.github.io/posts/golang-channel-study-5-1/</guid>
      <description>&lt;p&gt;本文是对Go 101中关于“并发开发”内容的梳理。请借鉴操作系统中的“管程”概念对channel的内部工作原理进行理解。&lt;/p&gt;</description>
    </item><item>
      <title>Golang 并发开发实践（4）- 爬虫服务的并发优化</title>
      <link>https://taodanfang.github.io/posts/golang-channel-study-4-1/</link>
      <pubDate>Fri, 26 Nov 2021 15:50:33 +0800</pubDate>
      
      <guid>https://taodanfang.github.io/posts/golang-channel-study-4-1/</guid>
      <description>&lt;p&gt;In this post, we will look at a small I/O intensive problem and explore different ways of doing this operation concurrently using the Go programming language, as a practical way of using concurrency in practice.&lt;/p&gt;</description>
    </item><item>
      <title>Golang 并发开发实践（3）- 详解</title>
      <link>https://taodanfang.github.io/posts/golang-channel-study-3-1/</link>
      <pubDate>Thu, 25 Nov 2021 21:26:25 +0800</pubDate>
      
      <guid>https://taodanfang.github.io/posts/golang-channel-study-3-1/</guid>
      <description>&lt;p&gt;掌握channel的关键是，时刻把握操作的阻塞情况，协程一旦阻塞，将会让出执行，系统会选择其他协程投入运行。系统一旦发现所有协程都处于阻塞状态，则抛出“死锁”异常！因此，这种基于channel的消息通信机制，完全在用户的控制之下实现了安全的程序逻辑（从而尽量避免了传统基于锁的安全保护机制）。&lt;/p&gt;</description>
    </item><item>
      <title>Golang 并发开发实践（2）- 用户并发注册开发实践</title>
      <link>https://taodanfang.github.io/posts/golang-channel-study-2-1/</link>
      <pubDate>Tue, 23 Nov 2021 23:55:41 +0800</pubDate>
      
      <guid>https://taodanfang.github.io/posts/golang-channel-study-2-1/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll use goroutines, channels and WaitGroups to process a &amp;ldquo;bulk user registration&amp;rdquo; request.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>