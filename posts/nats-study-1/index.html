<!DOCTYPE html>
<html lang="" dir="ltr">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>NATs 技术学习及其开发模式 &middot; CC-Table： 专注协同计算技术研发</title>
  <meta name="description" content="" />
  <link href="https://taodanfang.github.io/css/katex.css" rel="stylesheet">
  
  
  
  
  <link href="https://taodanfang.github.io/css/concated.min.css" rel="stylesheet">
  
  


</head>


  <body > 
    <div style="position: fixed; z-index: 500;
    width: 100vw; background-color: black; color: white;
    box-shadow: 0 0.4rem 2rem 0 rgba(0,0,0,0.2);">
        
<nav class="nav-bar side-padding" style="max-width: 100vw;"
>
  <h1 class="nav-header"><a href="https://taodanfang.github.io" 
    class="nav-text" style="color: wheat;">熙熙表格</a></h1>
 
  <h3 class="nav-header nav-text" 
  >
  <a href="#single-page-head" style="font-size: 18px; color:lightgreen; padding-top: 4px;">  NATs 技术学习及其开发模式</a>

</h3>
  
  <div class="hamburger-menu">
    <button onclick="hamburgerMenuPressed.call(this)" aria-haspopup="true" aria-expanded="false" aria-controls="menu" aria-label="Menu">
      <span  style="background-color: wheat;"></span>
      <span  style="background-color: wheat;"></span>
    </button>
    <ul id="menu" class="hamburger-menu-overlay">
      <li><a href="https://taodanfang.github.io" class="hamburger-menu-overlay-link">Home</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/bleve/" class="hamburger-menu-overlay-link">bleve</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/boltdb/" class="hamburger-menu-overlay-link">boltdb</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/casbin/" class="hamburger-menu-overlay-link">casbin</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/cc-table/" class="hamburger-menu-overlay-link">cc-table</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/channel/" class="hamburger-menu-overlay-link">channel</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/context/" class="hamburger-menu-overlay-link">context</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/crdt/" class="hamburger-menu-overlay-link">CRDT</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/d2admin/" class="hamburger-menu-overlay-link">d2admin</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/deployment/" class="hamburger-menu-overlay-link">deployment</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/distributed-computing/" class="hamburger-menu-overlay-link">distributed computing</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/drag-and-drop/" class="hamburger-menu-overlay-link">drag and drop</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/event/" class="hamburger-menu-overlay-link">event</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/go/" class="hamburger-menu-overlay-link">go</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/golang/" class="hamburger-menu-overlay-link">golang</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/goroutine/" class="hamburger-menu-overlay-link">goroutine</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/iot/" class="hamburger-menu-overlay-link">iot</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/kit/" class="hamburger-menu-overlay-link">kit</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/math/" class="hamburger-menu-overlay-link">math</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/microservice/" class="hamburger-menu-overlay-link">microservice</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/mongodb/" class="hamburger-menu-overlay-link">mongodb</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/nats/" class="hamburger-menu-overlay-link">nats</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/page/" class="hamburger-menu-overlay-link">page</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/practice/" class="hamburger-menu-overlay-link">practice</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/pubsub/" class="hamburger-menu-overlay-link">pubsub</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/rule/" class="hamburger-menu-overlay-link">rule</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/schedule/" class="hamburger-menu-overlay-link">“schedule&#34;</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/search/" class="hamburger-menu-overlay-link">search</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/socket.io/" class="hamburger-menu-overlay-link">socket.io</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/task/" class="hamburger-menu-overlay-link">task</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/tenant/" class="hamburger-menu-overlay-link">tenant</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/tree/" class="hamburger-menu-overlay-link">tree</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/vue/" class="hamburger-menu-overlay-link">vue</a></li>
      
      <li><a href="https://taodanfang.github.io/categories/websocket/" class="hamburger-menu-overlay-link">websocket</a></li>
      
      
    </ul>
  </div>
</nav>



    </div>

    <div class="single-body">
      <main id="single-page-head" class="content side-text-padding" style="margin-top: 108px;">
        <article class="post dropcase">
          <header class="post-header">

            <h1 class="post-title" >NATs 技术学习及其开发模式</h1>
            
            <div class="nav-bar">
              <p class="post-date">
                Posted 
                <time datetime="2021-08-04">Aug 4, 2021</time>
              </p>

              <div>
                <span style="font-size: 14px; padding-top: 0px;;"
                 id="busuanzi_container_site_uv">
                本站访客数
                <span style="padding-left: 4px; padding-right: 4px; color: red;"
                id="busuanzi_value_site_uv"></span> 人次, 
                </span>
                <span style="font-size: 14px; padding-bottom: 10px;;"
                id="busuanzi_container_page_pv">
                    本文总阅读量
                    <span style="padding-left: 4px; padding-right: 4px; color: red;"  
                    id="busuanzi_value_page_pv"></span> 次
                </span>
              </div>
            </div>
            
            

          </header>
          <picture class="post-figure">
            
            
            
            <source srcset="https://taodanfang.github.io/posts/nats-study-1/j9_hu9457979eecaa8d4ccc22c66440e72066_344904_711x0_resize_q75_lanczos.jpg 1x, https://taodanfang.github.io/posts/nats-study-1/j9_hu9457979eecaa8d4ccc22c66440e72066_344904_1422x0_resize_q75_lanczos.jpg 2x, https://taodanfang.github.io/posts/nats-study-1/j9_hu9457979eecaa8d4ccc22c66440e72066_344904_2133x0_resize_q75_lanczos.jpg 3x">
            <img src="https://taodanfang.github.io/posts/nats-study-1/j9_hu9457979eecaa8d4ccc22c66440e72066_344904_711x0_resize_q75_lanczos.jpg" >
          </picture>
          


          <div class="content-toc" style="min-width: 280px;" >
            <div style="margin-top: -20px;">
              <h2 style="margin-top: 10px;">目录</h2>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#what-is-nats">What is NATS</a></li>
    <li><a href="#qos">QOS</a></li>
    <li><a href="#nats-协议约定">NATS 协议约定</a></li>
    <li><a href="#nats-通信模型">NATS 通信模型</a>
      <ul>
        <li><a href="#1消息处理">1，消息处理</a></li>
        <li><a href="#2基于主题的消息">2，基于主题的消息</a></li>
      </ul>
    </li>
    <li><a href="#nats-应用场景">NATS 应用场景</a>
      <ul>
        <li><a href="#1广播">1，广播</a></li>
        <li><a href="#2对话">2，对话</a></li>
        <li><a href="#3负载均衡">3，负载均衡</a></li>
        <li><a href="#4确认">4，确认</a></li>
      </ul>
    </li>
    <li><a href="#nats-安装部署">NATs 安装部署</a></li>
    <li><a href="#nats-官方示例">NATs 官方示例</a>
      <ul>
        <li><a href="#pubsub">PUB/SUB</a></li>
        <li><a href="#requestreply">Request/Reply</a></li>
        <li><a href="#queue">Queue</a></li>
      </ul>
    </li>
    <li><a href="#nats-开发实践">NATs 开发实践</a>
      <ul>
        <li><a href="#json-消息">JSON 消息</a></li>
        <li><a href="#同步处理">同步处理</a></li>
        <li><a href="#支持-context">支持 Context</a></li>
      </ul>
    </li>
    <li><a href="#nats-stream">NATS Stream</a>
      <ul>
        <li><a href="#安装与启动">安装与启动</a></li>
        <li><a href="#与-jetstream-区别">与 JetStream 区别</a></li>
      </ul>
    </li>
    <li><a href="#jetstream">JetStream</a>
      <ul>
        <li><a href="#jetstream-简介">JetStream 简介</a></li>
        <li><a href="#基本概念">基本概念</a></li>
        <li><a href="#api">API</a></li>
      </ul>
    </li>
    <li><a href="#jetstream-示例">JetStream 示例</a>
      <ul>
        <li><a href="#简单实例">简单实例</a></li>
        <li><a href="#复杂实例">复杂实例</a></li>
        <li><a href="#生产者系统">生产者系统</a></li>
        <li><a href="#工作者消费系统">工作者消费系统</a></li>
        <li><a href="#监控者消费系统">监控者消费系统</a></li>
      </ul>
    </li>
    <li><a href="#消息源模拟器">消息源模拟器</a></li>
    <li><a href="#参考文献">参考文献</a></li>
  </ul>
</nav>
            </div>
          </div>

          <div class="next-post"  style="min-width: 250px;" >
            
            <a ontouchstart="cardPressed.call(this)" ontouchend="cardReleased.call(this)" ontouchmove="cardReleased.call(this)" 
  href="https://taodanfang.github.io/posts/iot-study-1/" class="card blog-card bc-next" rel="bookmark" >

  <article class="card-body">
    <h2 class="card-title">基于Go语言开发物联网项目(数传网关)相关基础</h2>
    <p class="card-text">本文介绍了基于go开发物联网相关项目过程中涉及到的基本技术，包括：数据编解码，基础通信协议设计与运行等等。在物联网项目开发过程中，一般均涉及到定制协议的设计与开发，同时一般均以二进制数据进行传送，根据一般的需求，本文提供了相应的软件模板。
</p>
    <div class="card-subtext muted-text">
      <p>Posted <time datetime="2021-08-02 82:00">Aug 2, 2021</time></p>
      <p>#golang #iot </p>
    </div>
  </article>
</a>
            
          </div>

          <p>NATs 是一个开源的、轻量级的高性能消息分发系统。NATs 的消息基于主题进行分发，不依赖于网络位置。</p>
<p>NATS的协议是一个简单的、基于文本的发布/订阅风格的协议。客户端连接到 gnatsd（NATS服务器），并与 gnatsd 进行通信，通信基于普通的 TCP/IP 套接字，并定义了很小的操作集，换行表示终止。与传统的、使用了二进制消息格式的消息通信系统不同，使用了基于文本的 NATS 协议，使得客户端实现很简单，可以方便地选择多种编程语言或脚本语言来实现。</p>
<h2 id="what-is-nats">What is NATS</h2>
<p>NATs is an open source, lightweight and high performance native message system developed by go language. NATs messages are handled by the subject and do not depend on the network location. It provides an abstraction layer between an application or service and the underlying physical network. The data is encoded and sent as a message by the publisher. Messages are received, decoded, and processed by one or more subscribers.</p>
<p><img src="image-20210804161439846.png" alt="image-20210804161439846"></p>
<blockquote>
<p>设计哲学：认为高质量的QoS应该在客户端构建</p>
</blockquote>
<blockquote>
<p>应用场景：</p>
<ul>
<li>分发大量消息</li>
<li>给指定的实例、设备、用户发送数据。或发现连接到自己的实例、设备或用户</li>
<li>向应用或设备发送命令并接收命令执行结果</li>
<li>负载均衡，多路可伸缩能力，定位透明，容错</li>
</ul>
</blockquote>
<blockquote>
<p>NATS 与 NATS Streaming 的区别：NATS最多交付一次（fire and forget，消息发送后不管），不支持持久化，而NATS Streaming 是一个基于 NATS协议的数据流服务程序，支持至少交付一次，可用于</p>
<ul>
<li>从指定的时间或序列号还原事件流</li>
<li>终端持久化订阅</li>
<li>持久化或有保证的消息传送</li>
</ul>
</blockquote>
<blockquote>
<p>NATS支持的特性：</p>
<ul>
<li><strong>纯发布/订阅</strong>，永远不假定有接收者，总是在线</li>
<li><strong>基于文本的协议</strong></li>
<li>至多发送一次（TCP level reliability）
<ul>
<li>NATS立即向符合条件的订阅者发送消息，并不存留消息</li>
</ul>
</li>
<li>至少发送一次（<strong>NATS Streaming</strong>）
<ul>
<li>如果匹配的订阅者一时不在线，Message 将被存储直到它被传送给订阅者，并得到订阅者确认。除非该消息超时或存储空间耗尽</li>
</ul>
</li>
<li><strong>持久性订阅（NATS Streaming）</strong>
<ul>
<li>服务端维护持久性订阅者的订阅推送状态，这样，持久性订阅者就可以知道它们在上一次会话中是在哪儿断开的</li>
</ul>
</li>
<li><strong>Event 流服务（NATS Streaming）</strong>
<ul>
<li>根据时间戳、序列号或相对位差，消息被持久化存储在内存、文件或其它二级存储设备中</li>
</ul>
</li>
<li><strong>缓存最新一个或第一个值 （NATS Streaming）</strong>
<ul>
<li>订阅者连接上服务器以后，先向订阅者推送最近一次的publish消息</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="qos">QOS</h2>
<blockquote>
<p>信息的投递保证，分成三个等级：</p>
<ul>
<li>Qos0（At most once）</li>
<li>Qos1（At least once）</li>
<li>Qos2（Exactly once）</li>
</ul>
</blockquote>
<blockquote>
<p>At most once</p>
</blockquote>
<p>Publisher若是选择QOS0, 則表示发送出信息后，信息會被最多投递0-1次。
Subscriber若是选择QOS0, 则MQ只要投递給任意Subscriber, 就會把该信息从MQ內丢弃。
这种方式，通常用在不在意状态一致性的情境上（例如邮件系统），又或者是debug log</p>
<blockquote>
<p>At least once</p>
</blockquote>
<p>Qos1通常是通过Log或任意的持久化方式来保证。</p>
<p>Publisher若是选择QOS1，Publisher就要等待MQ把信息写到持久化的存储上。一旦失敗, Publisher需要自己handler, 反正會返回Error。
Subscriber若是选择QOS1, 就必須发送Ack給MQ，MQ才会从持久化的存储中删除该信息。一旦失敗, MQ就会尝试重新投递。</p>
<p>这个模式最常被采用，但会出现多次投递的情况，导致重复消费的问题。</p>
<blockquote>
<p>Exactly once</p>
</blockquote>
<p>为了防止上面的会发生請求被多次重複消費的問題。Al least once + 冪等 = Exactly Once</p>
<p>这种模式实现的代价很高，等价于要保证强一致性，会对吞吐量产生很大影响。因此，支持该模式的MQ不是很多，Kafka是其中之一。</p>
<blockquote>
<p>NATs支持的模式：</p>
<ul>
<li>NATS server 支持 Qos0</li>
<li>NATS streaming 支持 Qos1</li>
</ul>
</blockquote>
<p><img src="image-20210805142832679.png" alt="image-20210805142832679"></p>
<h2 id="nats-协议约定">NATS 协议约定</h2>
<blockquote>
<p>一条NATS数据包包括如下内容：操作名 + 分隔符 + 内容</p>
<p>操作名（大小写不敏感）如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th>操作名</th>
<th>发送者</th>
<th>描述（内容）</th>
</tr>
</thead>
<tbody>
<tr>
<td>INFO</td>
<td>Server</td>
<td>初始化TCP/IP连接后发送给客户端</td>
</tr>
<tr>
<td>CONNECT</td>
<td>Client</td>
<td>发送给服务器指定连接信息</td>
</tr>
<tr>
<td>PUB</td>
<td>Client</td>
<td>发布消息到主题或Reply主题。注意：PUB 操作只能针对具体的某个topic(收件箱)，不能使用通配置符！</td>
</tr>
<tr>
<td>SUB</td>
<td>Client</td>
<td>订阅主题（或主题通配符）</td>
</tr>
<tr>
<td>UNSUB</td>
<td>Client</td>
<td>取消订阅主题（或自动取消订阅）</td>
</tr>
<tr>
<td>MSG</td>
<td>Server</td>
<td>交付一条消息负载给订阅者</td>
</tr>
<tr>
<td>PING</td>
<td>C/S</td>
<td>保持连接有效的PING活跃消息</td>
</tr>
<tr>
<td>PONG</td>
<td>C/S</td>
<td>保持连接有效的PONG活跃消息</td>
</tr>
<tr>
<td>+OK</td>
<td>Server</td>
<td>确认详细（Verbose）模式下协议消息的合法（对应CONNECT)</td>
</tr>
<tr>
<td>-ERR</td>
<td>Server</td>
<td>指示协议错误，会导致客户端断开连接</td>
</tr>
</tbody>
</table>
<blockquote>
<p>测试方法：可以采用Telnet连接服务器进行测试</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">telnet demo.nats.io <span style="color:#666">4222</span>
 
Trying 107.170.221.32...
Connected to demo.nats.io.
Escape character is<span style="color:#ba2121">&#39;^]&#39;</span>.

<span style="color:#408080;font-style:italic"># 收到 Server</span>
INFO <span style="color:#666">{</span><span style="color:#ba2121">&#34;server_id&#34;</span>:<span style="color:#ba2121">&#34;1ec445b504f4edfb4cf7927c707dd717&#34;</span>,<span style="color:#ba2121">&#34;version&#34;</span>:<span style="color:#ba2121">&#34;0.6.6&#34;</span>,<span style="color:#ba2121">&#34;go&#34;</span>:<span style="color:#ba2121">&#34;go1.4.2&#34;</span>,<span style="color:#ba2121">&#34;host&#34;</span>:<span style="color:#ba2121">&#34;0.0.0.0&#34;</span>,<span style="color:#ba2121">&#34;port&#34;</span>:4222,<span style="color:#ba2121">&#34;
</span><span style="color:#ba2121">
</span><span style="color:#ba2121"># Client 向 Server 发送操作
</span><span style="color:#ba2121">CONNECT {&#34;</span>verbose<span style="color:#ba2121">&#34;:false,&#34;</span>pedantic<span style="color:#ba2121">&#34;:false,&#34;</span>ssl_required<span style="color:#ba2121">&#34;:false,&#34;</span>name<span style="color:#ba2121">&#34;:&#34;&#34;,&#34;</span>lang<span style="color:#ba2121">&#34;:&#34;</span>go<span style="color:#ba2121">&#34;,&#34;</span>version<span style="color:#ba2121">&#34;:&#34;</span>1.1.0<span style="color:#ba2121">&#34;}\r\n
</span><span style="color:#ba2121">
</span></code></pre></div><h2 id="nats-通信模型">NATS 通信模型</h2>
<h3 id="1消息处理">1，消息处理</h3>
<p>应用程序的数据被编码为一条消息，并通过发布者发送出去；订阅者接收到消息，进行解码，再处理。订阅者处理NATS消息可以是同步的或异步的。</p>
<ul>
<li>异步处理
<ul>
<li>使用回调消息句柄处理消息，当有消息到来时，已注册的回调句柄接收并控制处理消息。整个过程客户端不会被阻塞，可以同步执行其它任务。异步处理可以采用多线程调度的设计。</li>
</ul>
</li>
<li>同步处理
<ul>
<li>需要应用程序显式调用方法来处理到来的消息。这种显示调用是阻塞式的调用，会暂停任务直到消息可用。如果没有可用的消息，消息处理阻塞的周期由客户端设置。同步处理通常用于服务器等待并处理传入的请求消息，并发送响应给客户端。</li>
</ul>
</li>
</ul>
<h3 id="2基于主题的消息">2，基于主题的消息</h3>
<blockquote>
<p>subject is a string of characters that publishers and subscribers can use to find each other’s names.</p>
</blockquote>
<p><img src="image-20210709184303198.png" alt="image-20210709184303198"></p>
<ul>
<li>主题支持层次
<ul>
<li>以&quot;.&ldquo;分割层次</li>
<li>支持单层通配符&rdquo;*&quot;</li>
<li>支持多层通配符&quot;&gt;&quot;</li>
</ul>
</li>
</ul>
<h2 id="nats-应用场景">NATS 应用场景</h2>
<h3 id="1广播">1，广播</h3>
<blockquote>
<p>NATs implements a publish subscribe message distribution model of one to many communication. The publisher sends a message about the topic and any active subscribers listening to the topic receive the message. Subscribers can also register content interested in Wildcard <a href="https://developpaper.com/tag/theme/">theme</a>s, which work a bit like regular expressions (but only a little). This one to many pattern is sometimes called fan out.</p>
<p>NATs实现了一种一对多的消息分发机制。发布者发布某个主题的消息，任何活跃的订阅者通过监听所感兴趣的主题来接收消息。</p>
</blockquote>
<p><img src="image-20210805193940641.png" alt="image-20210805193940641"></p>
<blockquote>
<p>NATS的发布/订阅通信模型是一对多的消息通信。发布者在一个主题上发送消息，任何注册（订阅）了此主题的客户端都可以接收到该主题的消息。订阅者可以使用主题通配符订阅感兴趣的主题。有时被称为扇出(fan-out)</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)
<span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()

nc.<span style="color:#00f">Publish</span>(<span style="color:#ba2121">&#34;foo&#34;</span>, []<span style="color:#008000">byte</span>(<span style="color:#ba2121">&#34;Hello World!&#34;</span>))
</code></pre></div><div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)
<span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()

nc.<span style="color:#00f">Subscribe</span>(<span style="color:#ba2121">&#34;foo&#34;</span>, <span style="color:#008000;font-weight:bold">func</span>(m <span style="color:#666">*</span>nats.Msg) {
    fmt.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Received a message: %s\n&#34;</span>, <span style="color:#008000">string</span>(m.Data))
})
</code></pre></div><blockquote>
<p>对于订阅者，可以选择异步处理或同步处理接收到的消息。如果异步处理消息，消息交付给订阅者的消息句柄。如果客户端没有句柄，那么该消息通信是同步的，那么客户端可能会被阻塞，直到它处理了当前消息。</p>
</blockquote>
<h3 id="2对话">2，对话</h3>
<blockquote>
<p>The request is published together with the answer topic on a given topic, and the responder listens for the topic and sends the response to the answer topic. The reply topic is usually a topic called “inbox”, which will be dynamically directed back to the requester, regardless of the location of either party. The ability of NATs even allows multiple responses, the first of which is utilized and the system effectively discards the additional responses. This allows a complex pattern to have multiple responders to reduce response latency and jitter.</p>
<p>NATs基于pubsub机制实现了request/reply通信。请求者发布一个request时会针对某个主题伴随一个回复主题，响应者监听某个主题，并发回该回复主题的reply。该reply topic 通常称为“inbox&quot;。 NATs允许发回多个response，其中通过首个response，可以有效地抛弃其余的response。</p>
</blockquote>
<p><img src="image-20210805194008730.png" alt="image-20210805194008730"></p>
<blockquote>
<p>NATS支持两种请求-响应消息通信：</p>
<ul>
<li>
<p>P2P（点对点）</p>
</li>
<li>
<p>O2M（一对多）</p>
</li>
</ul>
<p>P2P最快、响应也最先。</p>
<p>而对于O2M，需要设置请求者可以接收到的响应数量界限（默认只能收到一条来自订阅者的响应，并且是随机的）</p>
</blockquote>
<blockquote>
<p>在请求-响应模式，发布请求操作会发布一个带预期响应的消息到Reply主题。请求创建了一个收件箱，并在收件箱执行调用，并进行响应和返回。多个订阅者订阅了同一个主题，请求者向该主题发送一个请求，默认只收到一个订阅者的响应(随机)。</p>
<p>事实上，NATS协议中并没有定义 “请求” 或 &ldquo;响应&quot;方法，它是通过 SUB/PUB变相实现的：请求者先通过SUB创建一个收件箱，然后发送一个带 reply-to 的PUB，响应者收到PUB消息后，向 reply-to 发送响应消息，从而实现请求/响应。reply-to和收件箱都是一个 subject，前者是后者的子集。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)
<span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()

nc.<span style="color:#00f">Subscribe</span>(<span style="color:#ba2121">&#34;foo&#34;</span>, <span style="color:#008000;font-weight:bold">func</span>(m <span style="color:#666">*</span>nats.Msg) {
    nc.<span style="color:#00f">Publish</span>(m.Reply, []<span style="color:#008000">byte</span>(<span style="color:#ba2121">&#34;I will help you&#34;</span>))
})

reply, _ <span style="color:#666">:=</span> nc.<span style="color:#00f">Request</span>(<span style="color:#ba2121">&#34;foo&#34;</span>, []<span style="color:#008000">byte</span>(<span style="color:#ba2121">&#34;help&#34;</span>), <span style="color:#666">50</span><span style="color:#666">*</span>time.Millisecond)

fmt.<span style="color:#00f">Println</span>(<span style="color:#008000">string</span>(reply.Data))
</code></pre></div><h3 id="3负载均衡">3，负载均衡</h3>
<blockquote>
<p>NATs provides a built-in load balancing feature called distributed <a href="https://developpaper.com/tag/queue/">queue</a>s. Using queue subscribers balances messaging between a set of subscribers that can be used to provide application fault tolerance and large-scale workload processing. To create a queue subscription, you only need the subscriber to register the queue name. All subscribers with the same queue name form a queue group. No configuration is required. When a message is published on a registered topic, a member of the group is randomly selected to receive the message. Although the queue group has multiple subscribers, each message is used by only one subscriber. An important feature of NATs is that queue groups are defined by the application and its queue subscribers, not on the server configuration.</p>
<p>NATs内置了一种称为”分布式队列“的负载均衡机制。基于该机制可以实现针对订阅者的容错和大规模处理。对于创建一个queue订阅，只需要订阅者注册一个queue name，而无需额外的配置。所有注册同一个queue name的订阅者，构成了一个queue group。发布者像一个queue group发送一个消息后，该queue group中的一个随机成员（订阅者）会接受到消息。尤为重要的是，queue group在应用中定义，而非通过系统配置进行。</p>
</blockquote>
<p><img src="image-20210805194030931.png" alt="image-20210805194030931"></p>
<blockquote>
<p>NATS支持P2P消息通信的队列。</p>
<p>要创建一个消息队列，订阅者需注册一个队列名。所有的订阅者用同一个队列名，形成一个队列组。当消息发送到主题后，队列组会自动选择一个成员接收消息。尽管队列组有多个订阅者，但每条消息只能被组中的一个订阅者接收。</p>
<p>队列的订阅者可以是异步的，这意味着消息句柄以回调方式处理交付的消息。同步队列订阅者必须建立处理消息的逻辑。</p>
<p>队列模型一般常用于数据队列使用，例如：从网页上采集的数据经过处理直接写入到该队列，接收端一方可以起多个线程同时读取其中的一个队列，其中某些数据被一个线程消费了，其他线程就看不到了，这种方式是为了解决采集量巨大的情况下，后端服务可以动态调整并发数来消费这些数据。说白了就一点，上游生产数据太快，下游消费可能处理不过来，中间进行缓冲，下游就可以根据实际情况进行动态调整达到动态平衡。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)
<span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()

received <span style="color:#666">:=</span> <span style="color:#666">0</span>

nc.<span style="color:#00f">QueueSubscribe</span>(<span style="color:#ba2121">&#34;foo&#34;</span>, <span style="color:#ba2121">&#34;worker_group&#34;</span>, <span style="color:#008000;font-weight:bold">func</span>(_ <span style="color:#666">*</span>nats.Msg) {
    received<span style="color:#666">++</span>
})
</code></pre></div><h3 id="4确认">4，确认</h3>
<blockquote>
<p>In systems with up to one semantics, messages are sometimes lost. If your application is performing a request answer, it should use a timeout to handle any network or application failures. It’s always a good idea to set a timeout on a request and use code that handles the timeout. When publishing an event or data flow, one way to ensure message delivery is to convert it to a request reply with an ACK concept. In NATs, an ACK can be an empty message, a message without a payload.</p>
<p>对于消息丢失的情况，一般来说需要应用程序通过超时机制来处理。当发布一个 event 或 dataflow 时，确保正确发送的一个方法是采用 Ack。在NATs中，一个ack可以是一个空消息。</p>
</blockquote>
<p><img src="image-20210709184451125.png" alt="image-20210709184451125"></p>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)
<span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()
    
nc.<span style="color:#00f">Subscribe</span>(<span style="color:#ba2121">&#34;foo&#34;</span>, <span style="color:#008000;font-weight:bold">func</span>(m <span style="color:#666">*</span>nats.Msg) {
  	<span style="color:#408080;font-style:italic">// 注意与请求响应模式的区别
</span><span style="color:#408080;font-style:italic"></span>    <span style="color:#408080;font-style:italic">// nc.Publish(m.Reply, []byte(&#34;I will help you&#34;))
</span><span style="color:#408080;font-style:italic"></span>    m.<span style="color:#00f">Respond</span>([]<span style="color:#008000">byte</span>(<span style="color:#ba2121">&#34;&#34;</span>))
})
    
reply, _ <span style="color:#666">:=</span> nc.<span style="color:#00f">Request</span>(<span style="color:#ba2121">&#34;foo&#34;</span>, []<span style="color:#008000">byte</span>(<span style="color:#ba2121">&#34;help&#34;</span>), <span style="color:#666">50</span><span style="color:#666">*</span>time.Millisecond)
    
fmt.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;ack:&#34;</span>, <span style="color:#008000">string</span>(reply.Data))
</code></pre></div><h2 id="nats-安装部署">NATs 安装部署</h2>
<blockquote>
<p>采用docker方式安装并启动 nats</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo docker pull nats:latest
sudo docker run -p 4222:4222 -ti nats:latest
</code></pre></div><blockquote>
<p>采用源码安装</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">itable@itable:~$ mkdir nats
itable@itable:~$ <span style="color:#008000">cd</span> nats/

itable@itable:~/nats$ go mod init nats
go: creating new go.mod: module nats

itable@itable:~/nats$ go get github.com/nats-io/nats-server
itable@itable:~/nats$ go build github.com/nats-io/nats-server
itable@itable:~/nats$ go install github.com/nats-io/nats-server
itable@itable:~/nats$ ls
go.mod  go.sum  nats-server

itable@itable:~/nats$ ./nats-server 
<span style="color:#666">[</span>162121<span style="color:#666">]</span> 2021/08/05 14:59:39.946279 <span style="color:#666">[</span>INF<span style="color:#666">]</span> Starting nats-server version 1.4.1
<span style="color:#666">[</span>162121<span style="color:#666">]</span> 2021/08/05 14:59:39.947381 <span style="color:#666">[</span>INF<span style="color:#666">]</span> Git commit <span style="color:#666">[</span>not set<span style="color:#666">]</span>
<span style="color:#666">[</span>162121<span style="color:#666">]</span> 2021/08/05 14:59:39.952697 <span style="color:#666">[</span>INF<span style="color:#666">]</span> Listening <span style="color:#008000;font-weight:bold">for</span> client connections on 0.0.0.0:4222
<span style="color:#666">[</span>162121<span style="color:#666">]</span> 2021/08/05 14:59:39.953689 <span style="color:#666">[</span>INF<span style="color:#666">]</span> Server is ready
</code></pre></div><h2 id="nats-官方示例">NATs 官方示例</h2>
<blockquote>
<p>下载官方示例</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">itable@itable:~$ <span style="color:#008000">cd</span> nats/
itable@itable:~/nats$ go get github.com/nats-io/nats.go
go: downloading github.com/nats-io/nats.go v1.11.0
go: downloading github.com/nats-io/nkeys v0.3.0
go get: added github.com/nats-io/nats.go v1.11.0

<span style="color:#008000">cd</span> ~/go/pkg/mod/github.com/nats-io/nats.go@v1.11.0/examples
itable@itable:~/go/pkg/mod/github.com/nats-io/nats.go@v1.11.0/examples$ tree ./
├── nats-bench
│   └── main.go
├── nats-echo
│   └── main.go
├── nats-pub
│   └── main.go
├── nats-qsub
│   └── main.go
├── nats-req
│   └── main.go
├── nats-rply
│   └── main.go
└── nats-sub
    └── main.go
</code></pre></div><h3 id="pubsub">PUB/SUB</h3>
<blockquote>
<p>Nats-sub/main.go</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">        <span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>				<span style="color:#408080;font-style:italic">// urls = nats.DefaultURL
</span><span style="color:#408080;font-style:italic"></span>				<span style="color:#408080;font-style:italic">// opts = []
</span><span style="color:#408080;font-style:italic"></span>        nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#666">*</span>urls, opts<span style="color:#666">...</span>)
        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                log.<span style="color:#00f">Fatal</span>(err)
        }

				<span style="color:#408080;font-style:italic">// subj = 主题名称
</span><span style="color:#408080;font-style:italic"></span>        subj, i <span style="color:#666">:=</span> args[<span style="color:#666">0</span>], <span style="color:#666">0</span>

        nc.<span style="color:#00f">Subscribe</span>(subj, <span style="color:#008000;font-weight:bold">func</span>(msg <span style="color:#666">*</span>nats.Msg) {
                i <span style="color:#666">+=</span> <span style="color:#666">1</span>
                <span style="color:#00f">printMsg</span>(msg, i)
        })
        nc.<span style="color:#00f">Flush</span>()

        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">:=</span> nc.<span style="color:#00f">LastError</span>(); err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                log.<span style="color:#00f">Fatal</span>(err)
        }

        log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Listening on [%s]&#34;</span>, subj)
</code></pre></div><blockquote>
<p>Nats-pub/main.go</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">        <span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>        nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#666">*</span>urls, opts<span style="color:#666">...</span>)
        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                log.<span style="color:#00f">Fatal</span>(err)
        }
        <span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()

        subj, msg <span style="color:#666">:=</span> args[<span style="color:#666">0</span>], []<span style="color:#008000">byte</span>(args[<span style="color:#666">1</span>])

        <span style="color:#008000;font-weight:bold">if</span> reply <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> <span style="color:#666">&amp;&amp;</span> <span style="color:#666">*</span>reply <span style="color:#666">!=</span> <span style="color:#ba2121">&#34;&#34;</span> {
                nc.<span style="color:#00f">PublishRequest</span>(subj, <span style="color:#666">*</span>reply, msg)
        } <span style="color:#008000;font-weight:bold">else</span> {
                nc.<span style="color:#00f">Publish</span>(subj, msg)
        }

        nc.<span style="color:#00f">Flush</span>()

        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">:=</span> nc.<span style="color:#00f">LastError</span>(); err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                log.<span style="color:#00f">Fatal</span>(err)
        } <span style="color:#008000;font-weight:bold">else</span> {
                log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Published [%s] : &#39;%s&#39;\n&#34;</span>, subj, msg)
        }
</code></pre></div><blockquote>
<p>测试</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">nats-pub$ go run main.go msg.test <span style="color:#ba2121">&#34;hello&#34;</span>
Published <span style="color:#666">[</span>msg.test<span style="color:#666">]</span> : <span style="color:#ba2121">&#39;hello&#39;</span>

nats-sub$ go run main.go msg.test
Listening on <span style="color:#666">[</span>msg.test<span style="color:#666">]</span>
<span style="color:#666">[</span><span style="color:#408080;font-style:italic">#1] Received on [msg.test]: &#39;hello&#39;</span>
</code></pre></div><h3 id="requestreply">Request/Reply</h3>
<blockquote>
<p>Nats-rply/main.go</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>        nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#666">*</span>urls, opts<span style="color:#666">...</span>)
        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                log.<span style="color:#00f">Fatal</span>(err)
        }

				<span style="color:#408080;font-style:italic">// reply = &#34;回复主题&#34;
</span><span style="color:#408080;font-style:italic"></span>        subj, reply, i <span style="color:#666">:=</span> args[<span style="color:#666">0</span>], args[<span style="color:#666">1</span>], <span style="color:#666">0</span>

        nc.<span style="color:#00f">QueueSubscribe</span>(subj, <span style="color:#666">*</span>queueName, <span style="color:#008000;font-weight:bold">func</span>(msg <span style="color:#666">*</span>nats.Msg) {
                i<span style="color:#666">++</span>
                <span style="color:#00f">printMsg</span>(msg, i)
                msg.<span style="color:#00f">Respond</span>([]<span style="color:#008000">byte</span>(reply))
        })
        nc.<span style="color:#00f">Flush</span>()

        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">:=</span> nc.<span style="color:#00f">LastError</span>(); err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                log.<span style="color:#00f">Fatal</span>(err)
        }

        log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Listening on [%s]&#34;</span>, subj)
        <span style="color:#008000;font-weight:bold">if</span> <span style="color:#666">*</span>showTime {
                log.<span style="color:#00f">SetFlags</span>(log.LstdFlags)
        }
</code></pre></div><blockquote>
<p>Nats-req/main.go</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">        <span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>        nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#666">*</span>urls, opts<span style="color:#666">...</span>)
        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                log.<span style="color:#00f">Fatal</span>(err)
        }
        <span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()
        subj, payload <span style="color:#666">:=</span> args[<span style="color:#666">0</span>], []<span style="color:#008000">byte</span>(args[<span style="color:#666">1</span>])

        msg, err <span style="color:#666">:=</span> nc.<span style="color:#00f">Request</span>(subj, payload, <span style="color:#666">2</span><span style="color:#666">*</span>time.Second)
        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                <span style="color:#008000;font-weight:bold">if</span> nc.<span style="color:#00f">LastError</span>() <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                        log.<span style="color:#00f">Fatalf</span>(<span style="color:#ba2121">&#34;%v for request&#34;</span>, nc.<span style="color:#00f">LastError</span>())
                }
                log.<span style="color:#00f">Fatalf</span>(<span style="color:#ba2121">&#34;%v for request&#34;</span>, err)
        }

        log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Published [%s] : &#39;%s&#39;&#34;</span>, subj, payload)
        log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Received  [%v] : &#39;%s&#39;&#34;</span>, msg.Subject, <span style="color:#008000">string</span>(msg.Data))
</code></pre></div><blockquote>
<p>测试（可见，一般RR模式与Queue模式配合使用）</p>
<p>请求在给定的主题上与应答主题一起发布，应答者侦听该主题并将响应发送到应答主题。应答主题通常是一个称为_INBOX的主题，它将被动态地定向回请求者，而不考虑任何一方的位置。NATS的能力甚至允许多个响应，其中第一个响应被利用，而系统有效地丢弃了附加的响应。这允许一个复杂的模式有多个响应器减少响应延迟和抖动。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">nats-req$ go run main.go help.please <span style="color:#ba2121">&#34;I need help!&#34;</span>
Published <span style="color:#666">[</span>help.please<span style="color:#666">]</span> : <span style="color:#ba2121">&#39;I need help!&#39;</span>
Received  <span style="color:#666">[</span>_INBOX.LmVVzGMrL7aEccF2zfw9Yc.eZkBPPve<span style="color:#666">]</span> : <span style="color:#ba2121">&#39;OK, I CAN HELP!!!&#39;</span>

nats-rply$ go run main.go help.please <span style="color:#ba2121">&#34;OK, I CAN HELP!!!&#34;</span>
go run main.go help.please <span style="color:#ba2121">&#34;OK, I CAN HELPclear!&#34;</span>
Listening on <span style="color:#666">[</span>help.please<span style="color:#666">]</span>
<span style="color:#666">[</span><span style="color:#408080;font-style:italic">#1] Received on [help.please]: &#39;I need help!&#39;</span>
</code></pre></div><h3 id="queue">Queue</h3>
<blockquote>
<p>Nats-qsub/main.go</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">        <span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>        nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#666">*</span>urls, opts<span style="color:#666">...</span>)
        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                log.<span style="color:#00f">Fatal</span>(err)
        }

        subj, queue, i <span style="color:#666">:=</span> args[<span style="color:#666">0</span>], args[<span style="color:#666">1</span>], <span style="color:#666">0</span>

        nc.<span style="color:#00f">QueueSubscribe</span>(subj, queue, <span style="color:#008000;font-weight:bold">func</span>(msg <span style="color:#666">*</span>nats.Msg) {
                i<span style="color:#666">++</span>
                <span style="color:#00f">printMsg</span>(msg, i)
        })
        nc.<span style="color:#00f">Flush</span>()

        <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">:=</span> nc.<span style="color:#00f">LastError</span>(); err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
                log.<span style="color:#00f">Fatal</span>(err)
        }

        log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Listening on [%s], queue group [%s]&#34;</span>, subj, queue)
</code></pre></div><blockquote>
<p>测试（可以看到：my-queue组中只有一个subscriber，以及非my-queue组中的subscriber，收到了消息</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">nats-pub$ go run main.go foo <span style="color:#ba2121">&#34;Hello NATS!&#34;</span>
Published <span style="color:#666">[</span>foo<span style="color:#666">]</span> : <span style="color:#ba2121">&#39;Hello NATS!&#39;</span>

nats-qsub$ go run main.go foo my-queueListening on <span style="color:#666">[</span>foo<span style="color:#666">]</span>, queue group <span style="color:#666">[</span>my-queue<span style="color:#666">]</span>
<span style="color:#666">[</span><span style="color:#408080;font-style:italic">#1] Received on [foo] Queue[my-queue] Pid[164184]: &#39;Hello NATS!&#39;</span>

nats-qsub$ go run main.go foo my-queueListening on <span style="color:#666">[</span>foo<span style="color:#666">]</span>, queue group <span style="color:#666">[</span>my-queue<span style="color:#666">]</span>

nats-sub$ go run main.go foo
Listening on <span style="color:#666">[</span>foo<span style="color:#666">]</span>
<span style="color:#666">[</span><span style="color:#408080;font-style:italic">#1] Received on [foo]: &#39;Hello NATS!&#39;</span>
</code></pre></div><h2 id="nats-开发实践">NATs 开发实践</h2>
<h3 id="json-消息">JSON 消息</h3>
<blockquote>
<p>官方的示例代码存在一个问题, Publisher 和 Subscriber 发送和接收消息都是 msg *nats.Msg, 这个是封装好的结构体：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#408080;font-style:italic">// Msg is a structure used by Subscribers and PublishMsg().
</span><span style="color:#408080;font-style:italic">// nats客户端默认的消息传输结构, 字段分别是:
</span><span style="color:#408080;font-style:italic">// @1: 主题名
</span><span style="color:#408080;font-style:italic">// @2: 回复的主题名(如果回复对方,使用此主题)
</span><span style="color:#408080;font-style:italic">// @3: 数据
</span><span style="color:#408080;font-style:italic">// @4: 订阅信息
</span><span style="color:#408080;font-style:italic">// @5: 获取下一条Msg
</span><span style="color:#408080;font-style:italic"></span><span style="color:#008000;font-weight:bold">type</span> Msg <span style="color:#008000;font-weight:bold">struct</span> {
    Subject <span style="color:#b00040">string</span>
    Reply   <span style="color:#b00040">string</span>
    Data    []<span style="color:#b00040">byte</span>
    Sub     <span style="color:#666">*</span>Subscription
    next    <span style="color:#666">*</span>Msg
}
</code></pre></div><blockquote>
<p>支持JSON消息：nats.NewEncodedConn(nc, nats.JSON_ENCODER)</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="">#</span> 订阅者

<span style="color:#008000;font-weight:bold">type</span> person <span style="color:#008000;font-weight:bold">struct</span> {
	Name    <span style="color:#b00040">string</span>
	Address <span style="color:#b00040">string</span>
	Age     <span style="color:#b00040">int</span>
}

<span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">printMsgJson</span>(s <span style="color:#b00040">string</span>, p <span style="color:#666">*</span>person, i <span style="color:#b00040">int</span>) {
	log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;[#%d] Received on [%s]: &#39;%#v&#39;\n&#34;</span>, i, s, p)
}

<span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
	<span style="color:#008000;font-weight:bold">var</span> urls = flag.<span style="color:#00f">String</span>(<span style="color:#ba2121">&#34;s&#34;</span>, nats.DefaultURL, <span style="color:#ba2121">&#34;The nats server URLs (separated by comma)&#34;</span>)
	log.<span style="color:#00f">SetFlags</span>(<span style="color:#666">0</span>)
	flag.Usage = usage_json
	flag.<span style="color:#00f">Parse</span>()

	args <span style="color:#666">:=</span> flag.<span style="color:#00f">Args</span>()
	<span style="color:#008000;font-weight:bold">if</span> <span style="color:#008000">len</span>(args) <span style="color:#666">!=</span> <span style="color:#666">0</span> {
		<span style="color:#00f">showUsageAndExit_json</span>(<span style="color:#666">1</span>)
	}

	<span style="color:#408080;font-style:italic">// Connect Options.
</span><span style="color:#408080;font-style:italic"></span>	opts <span style="color:#666">:=</span> []nats.Option{nats.<span style="color:#00f">Name</span>(<span style="color:#ba2121">&#34;NATS Sample Subscriber&#34;</span>)}

	<span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>	c, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#666">*</span>urls, opts<span style="color:#666">...</span>)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}
	nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">NewEncodedConn</span>(c, nats.JSON_ENCODER)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}

	subj, i <span style="color:#666">:=</span> <span style="color:#ba2121">&#34;msg.test&#34;</span>, <span style="color:#666">0</span>

	nc.<span style="color:#00f">Subscribe</span>(subj, <span style="color:#008000;font-weight:bold">func</span>(p <span style="color:#666">*</span>person) {
		i <span style="color:#666">+=</span> <span style="color:#666">1</span>
		<span style="color:#00f">printMsgJson</span>(subj, p, i)
	})

	nc.<span style="color:#00f">Flush</span>()

	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">:=</span> nc.<span style="color:#00f">LastError</span>(); err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}

	log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Listening on [%s]&#34;</span>, subj)

	runtime.<span style="color:#00f">Goexit</span>()
}
</code></pre></div><div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="">#</span> 发布者

<span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
	<span style="color:#008000;font-weight:bold">var</span> urls = flag.<span style="color:#00f">String</span>(<span style="color:#ba2121">&#34;s&#34;</span>, nats.DefaultURL, <span style="color:#ba2121">&#34;The nats server URLs (separated by comma)&#34;</span>)

	log.<span style="color:#00f">SetFlags</span>(<span style="color:#666">0</span>)
	flag.Usage = usage_json
	flag.<span style="color:#00f">Parse</span>()

	args <span style="color:#666">:=</span> flag.<span style="color:#00f">Args</span>()
	<span style="color:#008000;font-weight:bold">if</span> <span style="color:#008000">len</span>(args) <span style="color:#666">!=</span> <span style="color:#666">0</span> {
		<span style="color:#00f">showUsageAndExit_json</span>(<span style="color:#666">1</span>)
	}

	<span style="color:#408080;font-style:italic">// Connect Options.
</span><span style="color:#408080;font-style:italic"></span>	opts <span style="color:#666">:=</span> []nats.Option{nats.<span style="color:#00f">Name</span>(<span style="color:#ba2121">&#34;NATS Sample Publisher&#34;</span>)}

	<span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>	c, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#666">*</span>urls, opts<span style="color:#666">...</span>)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}
	nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">NewEncodedConn</span>(c, nats.JSON_ENCODER)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}
	<span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()

	<span style="color:#008000;font-weight:bold">type</span> person <span style="color:#008000;font-weight:bold">struct</span> {
		Name    <span style="color:#b00040">string</span>
		Address <span style="color:#b00040">string</span>
		Age     <span style="color:#b00040">int</span>
	}

	me <span style="color:#666">:=</span> <span style="color:#666">&amp;</span>person{Name: <span style="color:#ba2121">&#34;derek&#34;</span>, Age: <span style="color:#666">22</span>, Address: <span style="color:#ba2121">&#34;85 Second St&#34;</span>}

	subj, msg <span style="color:#666">:=</span> <span style="color:#ba2121">&#34;msg.test&#34;</span>, me

	nc.<span style="color:#00f">Publish</span>(subj, msg)

	nc.<span style="color:#00f">Flush</span>()

	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">:=</span> nc.<span style="color:#00f">LastError</span>(); err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	} <span style="color:#008000;font-weight:bold">else</span> {
		log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Published [%s] : &#39;%#v&#39;\n&#34;</span>, subj, msg)
	}
}
</code></pre></div><blockquote>
<p>测试</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">go run sub_json.go
Listening on <span style="color:#666">[</span>msg.test<span style="color:#666">]</span>
<span style="color:#666">[</span><span style="color:#408080;font-style:italic">#1] Received on [msg.test]: &#39;&amp;main.person{Name:&#34;derek&#34;, Address:&#34;85 Second St&#34;, Age:22}&#39;</span>

go run pub_json.go
Published <span style="color:#666">[</span>msg.test<span style="color:#666">]</span> : <span style="color:#ba2121">&#39;&amp;main.person{Name:&#34;derek&#34;, Address:&#34;85 Second St&#34;, Age:22}&#39;</span>
</code></pre></div><h3 id="同步处理">同步处理</h3>
<blockquote>
<p>默认的 publish/subscribe 是属于异步方法, netchan 是属于同步方法, 一个 Subscriber 使用产方法订阅一个主题, 必须要等到消息来到才会 执行下面代码, 否则进行阻塞.</p>
</blockquote>
<blockquote>
<p>SUB端</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
	<span style="color:#008000;font-weight:bold">var</span> urls = flag.<span style="color:#00f">String</span>(<span style="color:#ba2121">&#34;s&#34;</span>, nats.DefaultURL, <span style="color:#ba2121">&#34;The nats server URLs (separated by comma)&#34;</span>)
	flag.<span style="color:#00f">Parse</span>()

	<span style="color:#408080;font-style:italic">// Connect Options.
</span><span style="color:#408080;font-style:italic"></span>	opts <span style="color:#666">:=</span> []nats.Option{nats.<span style="color:#00f">Name</span>(<span style="color:#ba2121">&#34;NATS Sample Subscriber&#34;</span>)}

	<span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>	c, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#666">*</span>urls, opts<span style="color:#666">...</span>)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}
	nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">NewEncodedConn</span>(c, nats.JSON_ENCODER)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}

	subj, i <span style="color:#666">:=</span> <span style="color:#ba2121">&#34;msg.test&#34;</span>, <span style="color:#666">0</span>

	recv <span style="color:#666">:=</span> <span style="color:#008000">make</span>(<span style="color:#008000;font-weight:bold">chan</span> <span style="color:#666">*</span>person_chan)
	nc.<span style="color:#00f">BindRecvChan</span>(subj, recv)

	nc.<span style="color:#00f">Flush</span>()
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">:=</span> nc.<span style="color:#00f">LastError</span>(); err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}

	log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Listening on [%s]&#34;</span>, subj)

	<span style="color:#008000;font-weight:bold">for</span> {
		p <span style="color:#666">:=</span> <span style="color:#666">&lt;-</span>recv
		i <span style="color:#666">+=</span> <span style="color:#666">1</span>
		<span style="color:#00f">printMsgJson_chan</span>(subj, p, i)
	}
}
</code></pre></div><blockquote>
<p>PUB 端</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
	<span style="color:#008000;font-weight:bold">var</span> urls = flag.<span style="color:#00f">String</span>(<span style="color:#ba2121">&#34;s&#34;</span>, nats.DefaultURL, <span style="color:#ba2121">&#34;The nats server URLs (separated by comma)&#34;</span>)
	flag.<span style="color:#00f">Parse</span>()

	<span style="color:#408080;font-style:italic">// Connect Options.
</span><span style="color:#408080;font-style:italic"></span>	opts <span style="color:#666">:=</span> []nats.Option{nats.<span style="color:#00f">Name</span>(<span style="color:#ba2121">&#34;NATS Sample Publisher&#34;</span>)}

	<span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>	c, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#666">*</span>urls, opts<span style="color:#666">...</span>)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}
	nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">NewEncodedConn</span>(c, nats.JSON_ENCODER)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	}
	<span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()

	<span style="color:#008000;font-weight:bold">type</span> person <span style="color:#008000;font-weight:bold">struct</span> {
		Name    <span style="color:#b00040">string</span>
		Address <span style="color:#b00040">string</span>
		Age     <span style="color:#b00040">int</span>
	}

	me <span style="color:#666">:=</span> <span style="color:#666">&amp;</span>person{Name: <span style="color:#ba2121">&#34;derek&#34;</span>, Age: <span style="color:#666">22</span>, Address: <span style="color:#ba2121">&#34;85 Second St&#34;</span>}

	subj, msg <span style="color:#666">:=</span> <span style="color:#ba2121">&#34;msg.test&#34;</span>, me

	snd <span style="color:#666">:=</span> <span style="color:#008000">make</span>(<span style="color:#008000;font-weight:bold">chan</span> <span style="color:#666">*</span>person)
	nc.<span style="color:#00f">BindSendChan</span>(subj, snd)

	snd <span style="color:#666">&lt;-</span> me

	nc.<span style="color:#00f">Flush</span>()

	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">:=</span> nc.<span style="color:#00f">LastError</span>(); err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Fatal</span>(err)
	} <span style="color:#008000;font-weight:bold">else</span> {
		log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Published [%s] : &#39;%#v&#39;\n&#34;</span>, subj, msg)
	}
}

</code></pre></div><blockquote>
<p>测试</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">go run sub_json_chan.go
Listening on <span style="color:#666">[</span>msg.test<span style="color:#666">]</span>
<span style="color:#666">[</span><span style="color:#408080;font-style:italic">#1] Received on [msg.test]: &#39;&amp;main.person_chan{Name:&#34;derek&#34;, Address:&#34;85 Second St&#34;, Age:22}&#39;</span>

go run pub_json_chan.go
Published <span style="color:#666">[</span>msg.test<span style="color:#666">]</span> : <span style="color:#ba2121">&#39;&amp;main.person{Name:&#34;derek&#34;, Address:&#34;85 Second St&#34;, Age:22}&#39;</span>
</code></pre></div><h3 id="支持-context">支持 Context</h3>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">ctx, cancel <span style="color:#666">:=</span> context.<span style="color:#00f">WithTimeout</span>(context.<span style="color:#00f">Background</span>(), <span style="color:#666">2</span><span style="color:#666">*</span>time.Second)
<span style="color:#008000;font-weight:bold">defer</span> <span style="color:#00f">cancel</span>()

nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)

<span style="color:#408080;font-style:italic">// Request with context
</span><span style="color:#408080;font-style:italic"></span>msg, err <span style="color:#666">:=</span> nc.<span style="color:#00f">RequestWithContext</span>(ctx, <span style="color:#ba2121">&#34;foo&#34;</span>, []<span style="color:#008000">byte</span>(<span style="color:#ba2121">&#34;bar&#34;</span>))

<span style="color:#408080;font-style:italic">// Synchronous subscriber with context
</span><span style="color:#408080;font-style:italic"></span>sub, err <span style="color:#666">:=</span> nc.<span style="color:#00f">SubscribeSync</span>(<span style="color:#ba2121">&#34;foo&#34;</span>)
msg, err <span style="color:#666">:=</span> sub.<span style="color:#00f">NextMsgWithContext</span>(ctx)

<span style="color:#408080;font-style:italic">// Encoded Request with context
</span><span style="color:#408080;font-style:italic"></span>c, err <span style="color:#666">:=</span> nats.<span style="color:#00f">NewEncodedConn</span>(nc, nats.JSON_ENCODER)
<span style="color:#008000;font-weight:bold">type</span> request <span style="color:#008000;font-weight:bold">struct</span> {
	Message <span style="color:#b00040">string</span> <span style="color:#ba2121">`json:&#34;message&#34;`</span>
}
<span style="color:#008000;font-weight:bold">type</span> response <span style="color:#008000;font-weight:bold">struct</span> {
	Code <span style="color:#b00040">int</span> <span style="color:#ba2121">`json:&#34;code&#34;`</span>
}
req <span style="color:#666">:=</span> <span style="color:#666">&amp;</span>request{Message: <span style="color:#ba2121">&#34;Hello&#34;</span>}
resp <span style="color:#666">:=</span> <span style="color:#666">&amp;</span>response{}
err <span style="color:#666">:=</span> c.<span style="color:#00f">RequestWithContext</span>(ctx, <span style="color:#ba2121">&#34;foo&#34;</span>, req, resp)
</code></pre></div><h2 id="nats-stream">NATS Stream</h2>
<h3 id="安装与启动">安装与启动</h3>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#008000">cd</span> nats
sudo go get github.com/nats-io/nats-streaming-server
sudo go build github.com/nats-io/nats-streaming-server
sudo go install github.com/nats-io/nats-streaming-server

<span style="color:#408080;font-style:italic"># 会自动启动 nats-server</span>
./nats-streaming-server 

<span style="color:#408080;font-style:italic"># 带监控的启动方式</span>
./nats-streaming-server -m <span style="color:#666">8222</span>

</code></pre></div><blockquote>
<p>http://localhost:8222</p>
</blockquote>
<p><img src="image-20210805212301657.png" alt="image-20210805212301657"></p>
<h3 id="与-jetstream-区别">与 JetStream 区别</h3>
<blockquote>
<p><code>NATS JetStream</code>（或者叫<code>JetStream</code>）是NATS基于<code>Raft</code>算法实现的最新的架构设计尝试解决上述问题的新方案。在区别于原有的<code>stan(NATS Streaming)</code>功能上，提供了新的持久化功能和消息送达策略，同时支持水平扩容。同时，新的<code>JetStream</code>也为大消息做了一些优化，不再将这特性功能作为<code>nats</code>的客户端存在而是嵌入<code>NATS Server</code>中作为其中的一个功能存在。也就是说，如果在对这几项技术进行选择时，<code>JetStream</code>应该是最应该被选择的方案。</p>
</blockquote>
<ul>
<li>启动方式</li>
</ul>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./nats-server -js 
</code></pre></div><p><img src="image-20210805214114143.png" alt="image-20210805214114143"></p>
<p><strong>The official support for NATS Streaming will be end by June 2023.</strong>(慎用)</p>
<h2 id="jetstream">JetStream</h2>
<blockquote>
</blockquote>
<h3 id="jetstream-简介">JetStream 简介</h3>
<blockquote>
<p>特性：</p>
<ul>
<li>At-least-once delivery（至少一次投递）</li>
<li>Exactly once within a window（正好一次投递）</li>
<li>Store messages and replay by time or sequence（消息持久，可按时间和顺序复现）</li>
<li>Wildcard support（消息通配符支持）</li>
<li>Account aware（账户）</li>
<li>Data at rest encryption（适时加密）</li>
<li>Cleanse specific messages (GDPR)</li>
<li>Horizontal scalability（水平扩展）</li>
<li>Persist Streams and replay via Consumers（消息流持久，基于消费者的消息复现）</li>
</ul>
</blockquote>
<blockquote>
<p>To that end, JetStream functionality is composed of server streams and server consumers.（功能上分为 server Stream，server Consumer）</p>
</blockquote>
<h3 id="基本概念">基本概念</h3>
<blockquote>
<p>Stream</p>
</blockquote>
<p>Streams define how messages are stored and retention duration. Streams consume normal NATS subjects, any message found on those subjects will be delivered to the defined storage system. You can do a normal publish to the subject for unacknowledged delivery, else if you send a Request to the subject the JetStream server will reply with an acknowledgement that it was stored.（<strong>Stream定义了消息如何存储及其保留期限。Stream可以绑定普通的NATS主题，任何属于这些主题的消息会被投递到Stream存储系统中</strong>）</p>
<blockquote>
<p>Consumer</p>
</blockquote>
<p>Each Consumer, or related group of Consumers, of a Stream will need a Consumer defined. It&rsquo;s ok to define thousands of these pointing at the same Stream. Consumers can either be <code>push</code> based where JetStream will deliver the messages as fast as possible (while adhering to the rate limit policy) to a subject of your choice or <code>pull</code> to have control by asking the server for messages. （<strong>Consumer 是Stream相关的消费者，同一个Stream可以定义成千上万的消费者。Consumer可以是push类型的，Jet会主动的尽可能快的向其投递消息；或者是pull类型的，通过server来控制消息的投递</strong>）</p>
<p>Consumers track their progress, they know what messages were delivered, acknowledged, etc., and will redeliver messages they sent that were not acknowledged. When first created, the Consumer has to know what message to send as the first one. You can configure either a specific message in the set (<code>StreamSeq</code>), specific time (<code>StartTime</code>), all (<code>DeliverAll</code>) or last (<code>DeliverLast</code>). This is the starting point and from there, they all behave the same - delivering all of the following messages with optional Acknowledgement.（<strong>Consumers跟踪了他们自己的进度，他们自己知道投递了、确认了什么消息，也会对未确认的消息进行重新投递。Consumer创建时，必须知晓那个消息是第一个消息，这可以通过设置进行确定，这是非常重要的起点</strong>）</p>
<p>Acknowledgements default to <code>AckExplicit</code> - the only supported mode for pull-based Consumers - meaning every message requires a distinct acknowledgement. But for push-based Consumers, you can set <code>AckNone</code> that does not require any acknowledgement, or <code>AckAll</code> which quite interestingly allows you to acknowledge a specific message, like message <code>100</code>, which will also acknowledge messages <code>1</code> through <code>99</code>. The <code>AckAll</code> mode can be a great performance boost.（pull类型的Consumer仅仅支持“AckExplicit”确认模式，这意味着每个消息需要一个显式的确认。push类型的Consumer可以选择多种确认模式，例如AckNone，AckAll等等）</p>
<blockquote>
<p>Messages are read or consumed from the Stream by Consumers.</p>
</blockquote>
<p>Pull-based Consumers require you to specifically ask for messages and ack them, typically you would do this with the client library <code>Request()</code> feature, but the <code>nats</code> utility has a helper: <strong>next</strong></p>
<p>Push-based Consumers will publish messages to a subject and anyone who subscribes to the subject will get them.</p>
<h3 id="api">API</h3>
<blockquote>
<p>with the Go SDK <a href="https://github.com/nats-io/nats.go">nats.go</a> v1.11.0, you can use same library for working with basic NATS and NATS JetStream.</p>
</blockquote>
<ul>
<li>管理类 API</li>
</ul>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">import</span> <span style="color:#ba2121">&#34;github.com/nats-io/nats.go&#34;</span>

<span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)

<span style="color:#408080;font-style:italic">// Create JetStream Context
</span><span style="color:#408080;font-style:italic"></span>js, _ <span style="color:#666">:=</span> nc.<span style="color:#00f">JetStream</span>()

<span style="color:#408080;font-style:italic">// Create a Stream
</span><span style="color:#408080;font-style:italic"></span>js.<span style="color:#00f">AddStream</span>(<span style="color:#666">&amp;</span>nats.StreamConfig{
	Name:     <span style="color:#ba2121">&#34;ORDERS&#34;</span>,
	Subjects: []<span style="color:#b00040">string</span>{<span style="color:#ba2121">&#34;ORDERS.*&#34;</span>},
})

<span style="color:#408080;font-style:italic">// Update a Stream
</span><span style="color:#408080;font-style:italic"></span>js.<span style="color:#00f">UpdateStream</span>(<span style="color:#666">&amp;</span>nats.StreamConfig{
	Name:     <span style="color:#ba2121">&#34;ORDERS&#34;</span>,
	MaxBytes: <span style="color:#666">8</span>,
})

<span style="color:#408080;font-style:italic">// Create a Consumer
</span><span style="color:#408080;font-style:italic"></span>js.<span style="color:#00f">AddConsumer</span>(<span style="color:#ba2121">&#34;ORDERS&#34;</span>, <span style="color:#666">&amp;</span>nats.ConsumerConfig{
	Durable: <span style="color:#ba2121">&#34;MONITOR&#34;</span>,
})

<span style="color:#408080;font-style:italic">// Delete Consumer
</span><span style="color:#408080;font-style:italic"></span>js.<span style="color:#00f">DeleteConsumer</span>(<span style="color:#ba2121">&#34;ORDERS&#34;</span>, <span style="color:#ba2121">&#34;MONITOR&#34;</span>)

<span style="color:#408080;font-style:italic">// Delete Stream
</span><span style="color:#408080;font-style:italic"></span>js.<span style="color:#00f">DeleteStream</span>(<span style="color:#ba2121">&#34;ORDERS&#34;</span>)
</code></pre></div><ul>
<li>操作类 API</li>
</ul>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">import</span> <span style="color:#ba2121">&#34;github.com/nats-io/nats.go&#34;</span>

<span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)

<span style="color:#408080;font-style:italic">// Create JetStream Context
</span><span style="color:#408080;font-style:italic"></span>js, _ <span style="color:#666">:=</span> nc.<span style="color:#00f">JetStream</span>(nats.<span style="color:#00f">PublishAsyncMaxPending</span>(<span style="color:#666">256</span>))

<span style="color:#408080;font-style:italic">// Simple Stream Publisher
</span><span style="color:#408080;font-style:italic"></span>js.<span style="color:#00f">Publish</span>(<span style="color:#ba2121">&#34;ORDERS.scratch&#34;</span>, []<span style="color:#008000">byte</span>(<span style="color:#ba2121">&#34;hello&#34;</span>))

<span style="color:#408080;font-style:italic">// Simple Async Stream Publisher
</span><span style="color:#408080;font-style:italic"></span><span style="color:#008000;font-weight:bold">for</span> i <span style="color:#666">:=</span> <span style="color:#666">0</span>; i &lt; <span style="color:#666">500</span>; i<span style="color:#666">++</span> {
	js.<span style="color:#00f">PublishAsync</span>(<span style="color:#ba2121">&#34;ORDERS.scratch&#34;</span>, []<span style="color:#008000">byte</span>(<span style="color:#ba2121">&#34;hello&#34;</span>))
}
<span style="color:#008000;font-weight:bold">select</span> {
<span style="color:#008000;font-weight:bold">case</span> <span style="color:#666">&lt;-</span>js.<span style="color:#00f">PublishAsyncComplete</span>():
<span style="color:#008000;font-weight:bold">case</span> <span style="color:#666">&lt;-</span>time.<span style="color:#00f">After</span>(<span style="color:#666">5</span> <span style="color:#666">*</span> time.Second):
	fmt.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;Did not resolve in time&#34;</span>)
}

<span style="color:#408080;font-style:italic">// Simple Async Ephemeral Consumer
</span><span style="color:#408080;font-style:italic"></span>js.<span style="color:#00f">Subscribe</span>(<span style="color:#ba2121">&#34;ORDERS.*&#34;</span>, <span style="color:#008000;font-weight:bold">func</span>(m <span style="color:#666">*</span>nats.Msg) {
	fmt.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Received a JetStream message: %s\n&#34;</span>, <span style="color:#008000">string</span>(m.Data))
})

<span style="color:#408080;font-style:italic">// Simple Sync Durable Consumer (optional SubOpts at the end)
</span><span style="color:#408080;font-style:italic"></span>sub, err <span style="color:#666">:=</span> js.<span style="color:#00f">SubscribeSync</span>(<span style="color:#ba2121">&#34;ORDERS.*&#34;</span>, nats.<span style="color:#00f">Durable</span>(<span style="color:#ba2121">&#34;MONITOR&#34;</span>), nats.<span style="color:#00f">MaxDeliver</span>(<span style="color:#666">3</span>))
m, err <span style="color:#666">:=</span> sub.<span style="color:#00f">NextMsg</span>(timeout)

<span style="color:#408080;font-style:italic">// Simple Pull Consumer
</span><span style="color:#408080;font-style:italic"></span>sub, err <span style="color:#666">:=</span> js.<span style="color:#00f">PullSubscribe</span>(<span style="color:#ba2121">&#34;ORDERS.*&#34;</span>, <span style="color:#ba2121">&#34;MONITOR&#34;</span>)
msgs, err <span style="color:#666">:=</span> sub.<span style="color:#00f">Fetch</span>(<span style="color:#666">10</span>)

<span style="color:#408080;font-style:italic">// Unsubscribe
</span><span style="color:#408080;font-style:italic"></span>sub.<span style="color:#00f">Unsubscribe</span>()

<span style="color:#408080;font-style:italic">// Drain
</span><span style="color:#408080;font-style:italic"></span>sub.<span style="color:#00f">Drain</span>()
</code></pre></div><h2 id="jetstream-示例">JetStream 示例</h2>
<blockquote>
<p>实例代码：https://github.com/shijuvar/go-distsys/tree/master/jsdemo</p>
<p>实例文档：https://shijuvar.medium.com/building-distributed-event-streaming-systems-in-go-with-nats-jetstream-3938e6dc7a13</p>
</blockquote>
<h3 id="简单实例">简单实例</h3>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#408080;font-style:italic">// 连接到nats的服务器
</span><span style="color:#408080;font-style:italic"></span>	conn, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(<span style="color:#ba2121">&#34;nats://127.0.0.1:4222&#34;</span>)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Panic</span>(err)
	}
	<span style="color:#008000;font-weight:bold">defer</span> conn.<span style="color:#00f">Close</span>()

	<span style="color:#408080;font-style:italic">// 初始化JetStream功能
</span><span style="color:#408080;font-style:italic"></span>	js, err <span style="color:#666">:=</span> conn.<span style="color:#00f">JetStream</span>()
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Panic</span>(err)
	}

	<span style="color:#408080;font-style:italic">// 判断Stream是否存在，如果不存在，那么需要创建这个Stream，否则会导致pub/sub失败
</span><span style="color:#408080;font-style:italic"></span>	stream, err <span style="color:#666">:=</span> js.<span style="color:#00f">StreamInfo</span>(streamName)
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Println</span>(err) <span style="color:#408080;font-style:italic">// 如果不存在，这里会有报错
</span><span style="color:#408080;font-style:italic"></span>	}
	<span style="color:#008000;font-weight:bold">if</span> stream <span style="color:#666">==</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;creating stream %q and subject %q&#34;</span>, streamName, subject)
		_, err = js.<span style="color:#00f">AddStream</span>(<span style="color:#666">&amp;</span>nats.StreamConfig{
			Name:     streamName,
			Subjects: []<span style="color:#b00040">string</span>{subject},
			MaxAge:   <span style="color:#666">3</span> <span style="color:#666">*</span> <span style="color:#666">24</span> <span style="color:#666">*</span> time.Hour,
		})
		<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
			log.<span style="color:#00f">Panicln</span>(err)
		}
	}

	<span style="color:#408080;font-style:italic">// 订阅消息
</span><span style="color:#408080;font-style:italic"></span>	sub, err <span style="color:#666">:=</span> js.<span style="color:#00f">Subscribe</span>(subject, cbHandle, nats.<span style="color:#00f">AckAll</span>(), nats.<span style="color:#00f">DeliverNew</span>())
	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Panic</span>(err)
		<span style="color:#008000;font-weight:bold">return</span>
	}
	<span style="color:#008000;font-weight:bold">defer</span> sub.<span style="color:#00f">Unsubscribe</span>()

	<span style="color:#408080;font-style:italic">// 发送消息
</span><span style="color:#408080;font-style:italic"></span>	js.<span style="color:#00f">Publish</span>(subject, []<span style="color:#008000">byte</span>(<span style="color:#ba2121">&#34;Hello World! &#34;</span><span style="color:#666">+</span>time.<span style="color:#00f">Now</span>().<span style="color:#00f">Format</span>(time.RFC3339)))

	time.<span style="color:#00f">Sleep</span>(<span style="color:#666">5</span> <span style="color:#666">*</span> time.Second)
	log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;Exiting...&#34;</span>)
</code></pre></div><blockquote>
<p>说明：在<code>Subscribe</code>消息时，在这里特别声明了<code>nats.DeliverNew()</code>这个选项。如果不声明，则默认为<code>nats.DeliverAll()</code>；除了这两个参数，还有一个<code>nats.DeliverLast()</code>参数，这分别对应了3种开始订阅时的方式：</p>
<ul>
<li><code>nats.DeliverAll()</code>，会读取有效生命周期内的所有消息，甚至包含已被处理的消息</li>
<li><code>nats.DeliverLast()</code>，会包含消息队列中的最后一条消息，即使被处理过的消息</li>
<li><code>nats.DeliverNew()</code>，只处理订阅之后的新消息</li>
</ul>
</blockquote>
<h3 id="复杂实例">复杂实例</h3>
<blockquote>
<p>Building Distributed Event Streaming Systems In Go With NATS JetStream</p>
</blockquote>
<ul>
<li>技术架构</li>
</ul>
<p><img src="image-20210805234703157.png" alt="image-20210805234703157"></p>
<ul>
<li>创建 JetStream Context</li>
</ul>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">import</span> <span style="color:#ba2121">&#34;github.com/nats-io/nats.go&#34;</span>
nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)
js, err <span style="color:#666">:=</span> nc.<span style="color:#00f">JetStream</span>() <span style="color:#408080;font-style:italic">// Returns JetStreamContext
</span></code></pre></div><p>The <code>JetStreamContext</code> allows JetStream messaging and stream management. Once you create a JetStreamContext, you can easily work with the JetStream by using its Publish and Subscribe APIs.</p>
<ul>
<li>Consumer模型</li>
</ul>
<blockquote>
<p>JetStream provides two kinds of consumer (subscriber) systems:</p>
<ul>
<li>Pull based consumer and Push based consumer.</li>
<li>The Pull based consumers let JetStream pull the messages from consumer systems.</li>
<li>Pull based consumer systems are like work queues（工作队列）. Because the JetStream provides a ACK (acknowledgment) mechanism, you can easily scale Pull based consumer systems horizontally without the problem of duplication of messages. Pull based subscription is new to the NATS ecosystem.</li>
<li>The Push based consumers let JetStream pushing the messages to consumer systems, which can be a good choice for monitoring systems.</li>
</ul>
</blockquote>
<ul>
<li>需求说明</li>
</ul>
<blockquote>
<p>In this simple example, we use one <em>Stream</em> <code>“ORDERS”</code> to be used for subjects <code>“ORDERS.*”</code>.</p>
<p>该示例中采用一个Stream，来管理“ORDERS.*&ldquo;主题相关的所有消息</p>
<p>And just for the sake of demo, we publish messages over the subjects <code>“ORDERS.created”</code> and <code>“ORDERS.approved”</code>.</p>
<p>为了简单起见，仅仅支持两个具体的主题，即orders.created和orders.approved</p>
<p>One system will publish the messages with <code>“ORDERS.created&quot;</code> subject.</p>
<p>示例中需要一个发布orders.created主题消息的生产者系统</p>
<p>A Pull based consumer system subscribes the messages from <code>“ORDERS.created&quot;</code> subject, and being reactive to the events it does something and then publish another event with subject <code>“ORDERS.approved&quot;</code>.</p>
<p>示例中包括一个pull类型的工作者（消费者）系统，会订阅orders.created主题相关的消息，当收到该主题消息后，它会响应该消息，完成一些业务，最后向orders.approved主题发出消息</p>
<p>There is another Push based consumer system that subscribes the messages with a wildcard subscription <code>“ORDERS.*”</code> so that all events published over the <em>Stream</em> <code>“ORDERS”</code> can be received.</p>
<p>示例中包括一个push类型的监控者（消费者）系统，会订阅orders.*相关的所有消息。</p>
</blockquote>
<h3 id="生产者系统">生产者系统</h3>
<ul>
<li>main</li>
</ul>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
   <span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>   nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)
   <span style="color:#408080;font-style:italic">// Creates JetStreamContext
</span><span style="color:#408080;font-style:italic"></span>   js, err <span style="color:#666">:=</span> nc.<span style="color:#00f">JetStream</span>()
   <span style="color:#00f">checkErr</span>(err)
   <span style="color:#408080;font-style:italic">// Creates stream
</span><span style="color:#408080;font-style:italic"></span>   err = <span style="color:#00f">createStream</span>(js)
   <span style="color:#00f">checkErr</span>(err)
   <span style="color:#408080;font-style:italic">// Create orders by publishing messages
</span><span style="color:#408080;font-style:italic"></span>   err= <span style="color:#00f">createOrder</span>(js)
   <span style="color:#00f">checkErr</span>(err)
}
<span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">checkErr</span>(err <span style="color:#b00040">error</span>) {
   <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
      log.<span style="color:#00f">Fatal</span>(err)
   }
}
</code></pre></div><ul>
<li>初始化 Stream（本示例中通过编程的方式创建Stream，也可以通过命令行工具nats创建）</li>
</ul>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">const</span> (
   streamName  = <span style="color:#ba2121">&#34;ORDERS&#34;</span>
   streamSubjects = <span style="color:#ba2121">&#34;ORDERS.*&#34;</span>
)
<span style="color:#408080;font-style:italic">// createStream creates a stream by using JetStreamContext
</span><span style="color:#408080;font-style:italic"></span><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">createStream</span>(js nats.JetStreamContext) <span style="color:#b00040">error</span> {
   <span style="color:#408080;font-style:italic">// Check if the ORDERS stream already exists; if not, create it.
</span><span style="color:#408080;font-style:italic"></span>   stream, err <span style="color:#666">:=</span> js.<span style="color:#00f">StreamInfo</span>(streamName)
   <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
      log.<span style="color:#00f">Println</span>(err)
   }
   <span style="color:#008000;font-weight:bold">if</span> stream <span style="color:#666">==</span> <span style="color:#008000;font-weight:bold">nil</span> {
      log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;creating stream %q and subjects %q&#34;</span>, streamName, streamSubjects)
      _, err = js.<span style="color:#00f">AddStream</span>(<span style="color:#666">&amp;</span>nats.StreamConfig{
         Name:     streamName,
         Subjects: []<span style="color:#b00040">string</span>{streamSubjects},
      })
      <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
         <span style="color:#008000;font-weight:bold">return</span> err
      }
   }
   <span style="color:#008000;font-weight:bold">return</span> <span style="color:#008000;font-weight:bold">nil</span>
}
</code></pre></div><ul>
<li>初始化发布消息（创建一些订单order，并发布消息）</li>
</ul>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">const</span> (
   subjectName =<span style="color:#ba2121">&#34;ORDERS.created&#34;</span>
)
<span style="color:#408080;font-style:italic">// createOrder publishes stream of events  
</span><span style="color:#408080;font-style:italic">// with subject &#34;ORDERS.created&#34; 
</span><span style="color:#408080;font-style:italic"></span><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">createOrder</span>(js nats.JetStreamContext) <span style="color:#b00040">error</span>{
   <span style="color:#008000;font-weight:bold">var</span> order model.Order
   <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#666">:=</span> <span style="color:#666">1</span>; i <span style="color:#666">&lt;=</span> <span style="color:#666">10</span>; i<span style="color:#666">++</span> {
      order = model.Order{
         OrderID:    i,
         CustomerID: <span style="color:#ba2121">&#34;Cust-&#34;</span> <span style="color:#666">+</span> strconv.<span style="color:#00f">Itoa</span>(i),
         Status:     <span style="color:#ba2121">&#34;created&#34;</span>,
      }
      orderJSON, _ <span style="color:#666">:=</span> json.<span style="color:#00f">Marshal</span>(order)
      _, err <span style="color:#666">:=</span> js.<span style="color:#00f">Publish</span>(subjectName, orderJSON)
      <span style="color:#008000;font-weight:bold">if</span> err<span style="color:#666">!=</span><span style="color:#008000;font-weight:bold">nil</span> {
         <span style="color:#008000;font-weight:bold">return</span> err
      }
      log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Order with OrderID:%d has been published\n&#34;</span>,i)
   }
   <span style="color:#008000;font-weight:bold">return</span> <span style="color:#008000;font-weight:bold">nil</span>
}
</code></pre></div><h3 id="工作者消费系统">工作者消费系统</h3>
<blockquote>
<p>Pull based consumer being reactive to events</p>
</blockquote>
<blockquote>
<p>注意：其中采用的API是Pull类型的Subscribe接口，会结合Fetch进行循环遍历处理消息</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">const</span> (
   subSubjectName =<span style="color:#ba2121">&#34;ORDERS.created&#34;</span>
   pubSubjectName =<span style="color:#ba2121">&#34;ORDERS.approved&#34;</span>

)
<span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
   <span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>   nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)
   js, err <span style="color:#666">:=</span> nc.<span style="color:#00f">JetStream</span>()
   <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
      log.<span style="color:#00f">Fatal</span>(err)
   }
   <span style="color:#408080;font-style:italic">// Create Pull based consumer with maximum 128 inflight.
</span><span style="color:#408080;font-style:italic"></span>   <span style="color:#408080;font-style:italic">// PullMaxWaiting defines the max inflight pull requests.
</span><span style="color:#408080;font-style:italic"></span>   sub, _ <span style="color:#666">:=</span> js.<span style="color:#00f">PullSubscribe</span>(subSubjectName, <span style="color:#ba2121">&#34;order-review&#34;</span>, nats.<span style="color:#00f">PullMaxWaiting</span>(<span style="color:#666">128</span>))
   ctx, cancel <span style="color:#666">:=</span> context.<span style="color:#00f">WithTimeout</span>(context.<span style="color:#00f">Background</span>(), <span style="color:#666">10</span><span style="color:#666">*</span>time.Second)
   <span style="color:#008000;font-weight:bold">defer</span> <span style="color:#00f">cancel</span>()
	
   <span style="color:#408080;font-style:italic">// 循环Pull（抽取）order 消息，并依次进行处理 order
</span><span style="color:#408080;font-style:italic"></span>   <span style="color:#008000;font-weight:bold">for</span> {
      <span style="color:#008000;font-weight:bold">select</span> {
      <span style="color:#008000;font-weight:bold">case</span> <span style="color:#666">&lt;-</span>ctx.<span style="color:#00f">Done</span>():
         <span style="color:#008000;font-weight:bold">return</span>
      <span style="color:#008000;font-weight:bold">default</span>:
      }
      msgs, _ <span style="color:#666">:=</span> sub.<span style="color:#00f">Fetch</span>(<span style="color:#666">10</span>, nats.<span style="color:#00f">Context</span>(ctx))
      <span style="color:#008000;font-weight:bold">for</span> _, msg <span style="color:#666">:=</span> <span style="color:#008000;font-weight:bold">range</span> msgs {
         msg.<span style="color:#00f">Ack</span>()
         <span style="color:#008000;font-weight:bold">var</span> order model.Order
         err <span style="color:#666">:=</span> json.<span style="color:#00f">Unmarshal</span>(msg.Data, <span style="color:#666">&amp;</span>order)
         <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
            log.<span style="color:#00f">Fatal</span>(err)
         }
         log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;order-review service&#34;</span>)
         log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;OrderID:%d, CustomerID: %s, Status:%s\n&#34;</span>, order.OrderID, order.CustomerID, order.Status)
         <span style="color:#00f">reviewOrder</span>(js,order)
      }
   }
}

<span style="color:#408080;font-style:italic">// 没处理一个 order，会修改 order 的状态，然后发布一个新消息
</span><span style="color:#408080;font-style:italic">// reviewOrder reviews the order and publishes ORDERS.approved event
</span><span style="color:#408080;font-style:italic"></span><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">reviewOrder</span>(js nats.JetStreamContext, order model.Order) {
   <span style="color:#408080;font-style:italic">// Changing the Order status
</span><span style="color:#408080;font-style:italic"></span>   order.Status =<span style="color:#ba2121">&#34;approved&#34;</span>
   orderJSON, _ <span style="color:#666">:=</span> json.<span style="color:#00f">Marshal</span>(order)
   _, err <span style="color:#666">:=</span> js.<span style="color:#00f">Publish</span>(pubSubjectName, orderJSON)
   <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
      log.<span style="color:#00f">Fatal</span>(err)
   }
   log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;Order with OrderID:%d has been %s\n&#34;</span>,order.OrderID, order.Status)
}
</code></pre></div><h3 id="监控者消费系统">监控者消费系统</h3>
<blockquote>
<p>注意：其中采用的API是PUSH类型的Subscribe接口，可以订阅通配符相关的主题消息，示例中采用了手工确认的模式；也可以采用QueueSubscribe接口</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
   <span style="color:#408080;font-style:italic">// Connect to NATS
</span><span style="color:#408080;font-style:italic"></span>   nc, _ <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(nats.DefaultURL)
   js, err <span style="color:#666">:=</span> nc.<span style="color:#00f">JetStream</span>()
   <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
      log.<span style="color:#00f">Fatal</span>(err)
   }
   <span style="color:#408080;font-style:italic">// Create durable consumer monitor
</span><span style="color:#408080;font-style:italic"></span>   js.<span style="color:#00f">Subscribe</span>(<span style="color:#ba2121">&#34;ORDERS.*&#34;</span>, <span style="color:#008000;font-weight:bold">func</span>(msg <span style="color:#666">*</span>nats.Msg) {
      msg.<span style="color:#00f">Ack</span>()
      <span style="color:#008000;font-weight:bold">var</span> order model.Order
      err <span style="color:#666">:=</span> json.<span style="color:#00f">Unmarshal</span>(msg.Data, <span style="color:#666">&amp;</span>order)
      <span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
         log.<span style="color:#00f">Fatal</span>(err)
      }

      log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;monitor service subscribes from subject:%s\n&#34;</span>, msg.Subject)
      log.<span style="color:#00f">Printf</span>(<span style="color:#ba2121">&#34;OrderID:%d, CustomerID: %s, Status:%s\n&#34;</span>, order.OrderID, order.CustomerID, order.Status)
   }, nats.<span style="color:#00f">Durable</span>(<span style="color:#ba2121">&#34;monitor&#34;</span>),nats.<span style="color:#00f">ManualAck</span>())

   runtime.<span style="color:#00f">Goexit</span>()

}
</code></pre></div><blockquote>
<p>注意：本示例中并未介绍Consumer相关的内容</p>
</blockquote>
<h2 id="消息源模拟器">消息源模拟器</h2>
<blockquote>
<p>在开发消息推送系统过程中，例如物联网数据采集模块，经常需要设置一个模拟的消息产生源，有必要实现一个满足此要求的基于定时器的消息发布模拟器，便于测试。示例如下：</p>
<ul>
<li>2个Topic，一个是<code>testTopic.any</code>, 另一个是<code>testTopic.ithome</code></li>
<li>2个Publisher，分別送出消息給這两个Topic</li>
<li>2个Subscriber，分別订阅<code>testTopic.*</code>和<code>testTopic.ithome</code></li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
	opts <span style="color:#666">:=</span> []nats.Option{nats.<span style="color:#00f">Timeout</span>(<span style="color:#666">10</span> <span style="color:#666">*</span> <span style="color:#666">60</span> <span style="color:#666">*</span> time.Second),
		nats.<span style="color:#00f">MaxReconnects</span>(<span style="color:#666">50</span>), nats.<span style="color:#00f">ReconnectWait</span>(<span style="color:#666">10</span> <span style="color:#666">*</span> time.Second), nats.<span style="color:#00f">ReconnectHandler</span>(<span style="color:#008000;font-weight:bold">func</span>(_ <span style="color:#666">*</span>nats.Conn) {
			log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;nats client reconnected&#34;</span>)
		})}

	<span style="color:#008000;font-weight:bold">var</span> URL <span style="color:#b00040">string</span> = <span style="color:#ba2121">&#34;nats://172.16.230.100:4222,nats://172.16.230.101:4222&#34;</span>
	nc, err <span style="color:#666">:=</span> nats.<span style="color:#00f">Connect</span>(URL, opts<span style="color:#666">...</span>)

	<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
		log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;nats connect :&#34;</span>, err)
	}
	<span style="color:#008000;font-weight:bold">defer</span> nc.<span style="color:#00f">Close</span>()

  <span style="color:#408080;font-style:italic">// 基于定时器进行模拟发送
</span><span style="color:#408080;font-style:italic"></span>	<span style="color:#008000;font-weight:bold">go</span> <span style="color:#008000;font-weight:bold">func</span>() {
		<span style="color:#008000;font-weight:bold">var</span> cnt = <span style="color:#666">0</span>
		timer <span style="color:#666">:=</span> time.<span style="color:#00f">NewTimer</span>(<span style="color:#666">1</span> <span style="color:#666">*</span> time.Second)
		<span style="color:#008000;font-weight:bold">for</span> {
			<span style="color:#666">&lt;-</span>timer.C
			log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;send:&#34;</span>, fmt.<span style="color:#00f">Sprintf</span>(<span style="color:#ba2121">&#34;hello_ithome_%d&#34;</span>, cnt))
			nc.<span style="color:#00f">Publish</span>(<span style="color:#ba2121">&#34;testTopic.ithome&#34;</span>, []<span style="color:#008000">byte</span>(fmt.<span style="color:#00f">Sprintf</span>(<span style="color:#ba2121">&#34;hello_ithome_%d&#34;</span>, cnt)))
			cnt<span style="color:#666">++</span>
			timer.<span style="color:#00f">Reset</span>(<span style="color:#666">3</span> <span style="color:#666">*</span> time.Second)
		}
	}()
	<span style="color:#008000;font-weight:bold">go</span> <span style="color:#008000;font-weight:bold">func</span>() {
		<span style="color:#008000;font-weight:bold">var</span> cnt = <span style="color:#666">0</span>
		timer <span style="color:#666">:=</span> time.<span style="color:#00f">NewTimer</span>(<span style="color:#666">3</span> <span style="color:#666">*</span> time.Second)
		<span style="color:#008000;font-weight:bold">for</span> {
			<span style="color:#666">&lt;-</span>timer.C
			log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;send:&#34;</span>, fmt.<span style="color:#00f">Sprintf</span>(<span style="color:#ba2121">&#34;hello_any_%d&#34;</span>, cnt))
			nc.<span style="color:#00f">Publish</span>(<span style="color:#ba2121">&#34;testTopic.any&#34;</span>, []<span style="color:#008000">byte</span>(fmt.<span style="color:#00f">Sprintf</span>(<span style="color:#ba2121">&#34;hello_any_%d&#34;</span>, cnt)))
			cnt<span style="color:#666">++</span>
			timer.<span style="color:#00f">Reset</span>(<span style="color:#666">5</span> <span style="color:#666">*</span> time.Second)
		}
	}()

	mcbAny <span style="color:#666">:=</span> <span style="color:#008000;font-weight:bold">func</span>(msg <span style="color:#666">*</span>nats.Msg) {
		log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;Any:&#34;</span>, <span style="color:#008000">string</span>(msg.Data))

	}
	mcbIthome <span style="color:#666">:=</span> <span style="color:#008000;font-weight:bold">func</span>(msg <span style="color:#666">*</span>nats.Msg) {
		log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;Ithome:&#34;</span>, <span style="color:#008000">string</span>(msg.Data))

	}
	<span style="color:#008000;font-weight:bold">var</span> Sub1Cb <span style="color:#666">*</span>nats.Subscription
	<span style="color:#008000;font-weight:bold">var</span> Sub2Cb <span style="color:#666">*</span>nats.Subscription
	<span style="color:#008000;font-weight:bold">go</span> <span style="color:#008000;font-weight:bold">func</span>() {
		Sub1Cb, err = nc.<span style="color:#00f">Subscribe</span>(<span style="color:#ba2121">&#34;testTopic.*&#34;</span>, mcbAny)
		<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
			log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;queue subscribe testTopic.*:&#34;</span>, err)
		}
	}()

	<span style="color:#008000;font-weight:bold">go</span> <span style="color:#008000;font-weight:bold">func</span>() {
		Sub2Cb, err = nc.<span style="color:#00f">Subscribe</span>(<span style="color:#ba2121">&#34;testTopic.ithome&#34;</span>, mcbIthome)
		<span style="color:#008000;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#008000;font-weight:bold">nil</span> {
			log.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;queue subscribe testTopic.ithome:&#34;</span>, err)
		}
	}()

	c <span style="color:#666">:=</span> <span style="color:#008000">make</span>(<span style="color:#008000;font-weight:bold">chan</span> os.Signal, <span style="color:#666">1</span>)
	signal.<span style="color:#00f">Notify</span>(c, os.Interrupt)

	<span style="color:#666">&lt;-</span>c
	Sub1Cb.<span style="color:#00f">Unsubscribe</span>()
	Sub2Cb.<span style="color:#00f">Unsubscribe</span>()
}
</code></pre></div><h2 id="参考文献">参考文献</h2>
<blockquote>
<ul>
<li><a href="https://developpaper.com/an-introduction-to-the-messaging-model-of-golang-nats/">https://developpaper.com/an-introduction-to-the-messaging-model-of-golang-nats/</a></li>
<li><a href="https://jacobmartins.com/2016/06/06/practical-golang-getting-started-with-nats-and-related-patterns/">https://jacobmartins.com/2016/06/06/practical-golang-getting-started-with-nats-and-related-patterns/</a></li>
<li><a href="https://www.cnblogs.com/yorkyang/p/8392752.html">https://www.cnblogs.com/yorkyang/p/8392752.html</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10245428">https://ithelp.ithome.com.tw/articles/10245428</a></li>
<li><a href="https://docs.nats.io/developing-with-nats/tutorials/pubsub">https://docs.nats.io/developing-with-nats/tutorials/pubsub</a></li>
<li><a href="https://github.com/nats-io/nats.go">https://github.com/nats-io/nats.go</a></li>
<li><a href="https://www.dazhuanlan.com/miyayeah/topics/977143">https://www.dazhuanlan.com/miyayeah/topics/977143</a></li>
<li><a href="https://www.cnblogs.com/zeppelin/p/7261033.html">https://www.cnblogs.com/zeppelin/p/7261033.html</a></li>
<li><a href="https://choria.io/blog/post/2020/03/30/nats_patterns_6/">https://choria.io/blog/post/2020/03/30/nats_patterns_6/</a></li>
<li><a href="https://github.com/shijuvar/go-distsys/tree/master/jsdemo">https://github.com/shijuvar/go-distsys/tree/master/jsdemo</a></li>
<li><a href="https://docs.nats.io/jetstream/jetstream">https://docs.nats.io/jetstream/jetstream</a></li>
</ul>
</blockquote>
        </article>
        

      </main>

      <nav class="end-nav">
        
        <a ontouchstart="cardPressed.call(this)" ontouchend="cardReleased.call(this)" ontouchmove="cardReleased.call(this)" 
  href="https://taodanfang.github.io/posts/iot-study-1/" class="card blog-card" rel="bookmark" >
  
  <div class="card-img-container">
    <p class="card-img-overlay">下一篇</p>
    <picture>
      
      
      
      <source srcset="https://taodanfang.github.io/posts/iot-study-1/j7_hu3d03a01dcc18bc5be0e67db3d8d209a6_143645_400x0_resize_q75_lanczos.jpg 1x, https://taodanfang.github.io/posts/iot-study-1/j7_hu3d03a01dcc18bc5be0e67db3d8d209a6_143645_800x0_resize_q75_lanczos.jpg 2x, https://taodanfang.github.io/posts/iot-study-1/j7_hu3d03a01dcc18bc5be0e67db3d8d209a6_143645_1200x0_resize_q75_lanczos.jpg 3x">
      <img src="https://taodanfang.github.io/posts/iot-study-1/j7_hu3d03a01dcc18bc5be0e67db3d8d209a6_143645_400x0_resize_q75_lanczos.jpg" class="card-img" >
    </picture>
  </div>
  
  <article class="card-body">
    <h2 class="card-title">基于Go语言开发物联网项目(数传网关)相关基础</h2>
    <p class="card-text">本文介绍了基于go开发物联网相关项目过程中涉及到的基本技术，包括：数据编解码，基础通信协议设计与运行等等。在物联网项目开发过程中，一般均涉及到定制协议的设计与开发，同时一般均以二进制数据进行传送，根据一般的需求，本文提供了相应的软件模板。
</p>
    <div class="card-subtext muted-text">
      <p>Posted <time datetime="2021-08-02 82:00">Aug 2, 2021</time></p>
      <p>#golang #iot </p>
    </div>
  </article>
</a>
        
      </nav>

      
        <script src="https://utteranc.es/client.js"
        repo="taodanfang/hugoblogtalks"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
        </script>
      

  </div>

  <footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</footer>
  
  <script defer src="https://taodanfang.github.io/js/katex.js"></script>


  <script defer src="https://taodanfang.github.io/js/auto-render.js" onload="renderMathInElement(document.body);"></script>


<script src="https://taodanfang.github.io/js/core.min.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

  <script>
    $('#TableOfContents a').click(function () {
      console.log("click");
    var target = $(this).attr('href');
    console.log(target);
    $('html, body').animate({
       scrollTop: $(target).offset().top - 108 
     }, 500);
     return false;
    });
    $('body > div:nth-child(1) > nav > h3 > a').click(function () {
      console.log("click");
    var target = $(this).attr('href');
    console.log(target);
    $('html, body').animate({
       scrollTop: $(target).offset().top - 108 
     }, 500);
     return false;
    });
  </script>
  </body>
</html>
